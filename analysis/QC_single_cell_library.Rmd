---
title: "QC of single cell libraries"
author: "Briana Mittlemant"
date: YYYY-MM-DD
output: html_document
---

```{r read-chunk, include=FALSE, cache=FALSE}
knitr::read_chunk("chunks.R")
```

```{r knitr-opts-chunk, include=FALSE}
```

**Last updated:** `r Sys.Date()`

**Code version:** `r workflowr::extract_commit(".", 1)$sha1`

```{r}
library("dplyr")
library("edgeR")
library("ggplot2")
library("cowplot")
theme_set(theme_bw(base_size = 16))
theme_update(panel.grid.minor.x = element_blank(),
             panel.grid.minor.y = element_blank(),
             panel.grid.major.x = element_blank(),
             panel.grid.major.y = element_blank(),
             legend.key = element_blank(),
             plot.title = element_text(size = rel(1)))
source("../../singleCellSeq/analysis/functions.R")
```

Summary counts from featureCounts program using gather-summary-counts.py. These data were colected from the summary files of the combined samples. The code below makes sure all samples are included.

```{r}
summary_per_sample <- read.table("../../singleCellSeq/data/summary-counts.txt",header=TRUE, stringsAsFactors= FALSE)

stopifnot(summary_per_sample$well != "bulk",
          sum(summary_per_sample$rmdup == "reads")==864,
          sum(summary_per_sample$rmdup == "molecules")==864)
          

```

Remove feautureCounts classification with zero counts. 
```{r}
stopifnot(colSums(summary_per_sample[, c(7, 10:15)]) == 0)
summary_per_sample <- summary_per_sample[, c(-7, -10:-15)]
head(summary_per_sample)
```
Input annotation.  

```{r}
anno <- read.table("../../singleCellSeq//data/annotation.txt", header = TRUE,
                   stringsAsFactors = FALSE)
stopifnot(anno$well != "bulk", nrow(anno) == 864,
          rep(anno$individual, each = 2) == summary_per_sample$individual,
          rep(anno$replicate, each = 2) == summary_per_sample$replicate,
          rep(anno$well, each = 2) == summary_per_sample$well)
head(anno)
```

Input read counts  

```{r}
reads <- read.table("../../singleCellSeq/data/reads.txt", header = TRUE,
                    stringsAsFactors = FALSE)
stopifnot(ncol(reads) == nrow(anno),
          colnames(reads) == anno$sample_id)
```

Input molecule counts

```{r}
molecules <- read.table("../../singleCellSeq//data/molecules.txt", header = TRUE,
                    stringsAsFactors = FALSE)
stopifnot(ncol(molecules) == nrow(anno),
          colnames(reads) == anno$sample_id)
```


Input single cell observation quality control data.  

```{r}
qc <- read.table("../../singleCellSeq/data/qc-ipsc.txt", header = TRUE,
                 stringsAsFactors = FALSE)
stopifnot(qc$individual == anno$individual,
          qc$replicate == anno$replicate,
          qc$well == anno$well)
head(qc)
```

###Total ERCC and removal of NA19098.r2
```{r}
summary_per_sample_reads <- summary_per_sample[summary_per_sample$rmdup == "reads",]
summary_per_sample_reads$sample_id <- anno$sample_id
summary_per_sample_reads$batch <- anno$batch
stopifnot(colnames(reads) == summary_per_sample_reads$sample_id )

summary_per_sample_reads$ERCC_reads <- apply(reads[grep("ERCC", rownames(reads)), ],2,sum)
summary_per_sample_reads$ERCC_molecules <- apply(molecules[grep("ERCC", rownames(molecules)), ],2,sum)
```

```{r}
## create a color palette with one color per individual and different shades for repplicates
great_color <- c("#CC3300", "#FF9966", "#FFCC99", "#006633", "#009900", "#99FF99", "#3366FF", "#6699FF", "#66CCFF")
great_color_8 <- c("#CC3300", "#FF9966", "#006633", "#009900", "#99FF99", "#3366FF", "#6699FF", "#66CCFF")

ercc_reads_plot <- ggplot(summary_per_sample_reads,
                   aes(x = factor(batch), y = ERCC_reads,
                   fill = factor(batch)), height = 600, width = 2000) +
                   geom_violin(alpha = .5) + 
                   geom_boxplot(alpha = .01, width = .2, position = position_dodge(width = .9)) +
                   scale_fill_manual(values = great_color) + 
                   labs(x = "", y = "Total ERCC read-counts per cell", 
                        title = "Excess amount of ERCC in NA19098.r2") +
                   theme(axis.text.x = element_text(hjust=1, angle = 45))

ercc_molecule_plot <- ggplot(summary_per_sample_reads,
                   aes(x = factor(batch), y = ERCC_molecules,
                   fill = factor(batch)), height = 600, width = 2000) +
                   geom_violin(alpha = .5) + 
                   geom_boxplot(alpha = .01, width = .2, position = position_dodge(width = .9)) +
                   scale_fill_manual(values = great_color) + 
                   labs(x = "", y = "Total ERCC molecule-counts per cell", 
                        title = "Excess amount of ERCC in NA19098.r2") +
                   theme(axis.text.x = element_text(hjust=1, angle = 45))

plot_grid(ercc_reads_plot + theme(legend.position=c(.8,.7)),
          ercc_molecule_plot + theme(legend.position = "none"),
          labels = LETTERS[1:2])
```
These plots show that in terms of the total read count and molecule count. NA19098.r2 had a large excess of ERCC per cell. We also see a lot more variability in the ERCC read and molecule counts in this sample/replicate.   
**Why could this be? **   
Understand ERCC RNA spike-ins by looking at the thermofisher documentation.    

* Purpose: RNA controlls for performance quality assessment (preformulated sets of 92 polyA transcripts from ERCC plasmid reference  

* Use: add Spike-in Mix to each sample (about 10^6-fold concentration)  

* Known mix1:mix2 ratios can be used to assess differencial gene expression   

Note from paper on this: "It appeared that too much ERCC spike-in mix was added to each cell"  
  
Remove NA19098r2 for all the following analsis:

```{r}
remove_19098r2 <- anno$batch != "NA19098.r2"
anno_rm <- anno[remove_19098r2,]
summary_per_sample_reads_rm <- summary_per_sample_reads[remove_19098r2,]
reads_rm <- reads[, remove_19098r2]
molecules_rm <- molecules[, remove_19098r2]

stopifnot(summary_per_sample_reads_rm$sample_id == colnames(reads_rm))
```

###Total mapped reads  
```{r}
## add cell number per well by merging qc file
summary_per_sample_reads_qc <- merge(summary_per_sample_reads_rm,qc,by=c("individual","replicate","well"))
## calculate total mapped reads per sample
summary_per_sample_reads_qc$total_mapped <- apply(summary_per_sample_reads_qc[,5:7],1,sum)

## cut off 
cut_off_reads <- quantile(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0,"total_mapped"], 0.95)

cut_off_reads
```
 
The cut off is the 95% percentile when there are 0 cells in the well. This is used to look for wells that appeared to have a cell but do not produce reads at the level expected for 1 cell. We are loooking for cells that were bad quality and therefore didn't produce ample reads. 95% cuttoff was used troughtout the study but it is an arbutrary number.  

```{r}
summary_per_sample_reads_qc$cut_off_reads <- summary_per_sample_reads_qc$total_mapped > cut_off_reads

## numbers of cells 
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "total_mapped"] > cut_off_reads)
```
Total mapped reads need to be higher than the 95% cuttoff found for 0 cell and the well needed to hold only one cell.  


```{r}
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "total_mapped"] <= cut_off_reads)
```

This is the number of wells that have 1 cell and have less than the 95% cut off for reads. In the data these cells act more like they did not have a cell in the well due to bad quality.  

```{r}
## density plots
plot_reads <- ggplot(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0 |
                                           summary_per_sample_reads_qc$cell_number == 1 , ],
       aes(x = total_mapped, fill = as.factor(cell_number))) + 
       geom_density(alpha = 0.5) +
       geom_vline(xintercept = cut_off_reads, colour="grey", linetype = "longdash") +
       labs(x = "Total mapped reads per sample", title = "Cutoff based on the number of total mapped reads", fill = "Cell number")

```

###Unmapped ratios  
```{r}
## calculate unmapped ratios
summary_per_sample_reads_qc$unmapped_ratios <- summary_per_sample_reads_qc[,8]/apply(summary_per_sample_reads_qc[,5:8],1,sum)

## cut off 
cut_off_unmapped <- quantile(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0,"unmapped_ratios"], 0.05)

cut_off_unmapped
```

This is similar to the step above. We are looking for the lower 5% of unmapped reads when no cell was present in the well. This is because when no cell is present we will have a lot of unmapped reads that come from the spikeins. 
```{r}
summary_per_sample_reads_qc$cut_off_unmapped <- summary_per_sample_reads_qc$unmapped_ratios < cut_off_unmapped

## numbers of cells 
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "unmapped_ratios"] >= cut_off_unmapped)
```

Now we look at the samples with 1 cell to see if they have more than the cuttoff of unmapped reads. This is to check mapping quality.  

```{r}
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "unmapped_ratios"] < cut_off_unmapped)
```

```{r}
# density plots
plot_unmapped <- ggplot(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0 |
                                           summary_per_sample_reads_qc$cell_number == 1 , ],
       aes(x = unmapped_ratios *100, fill = as.factor(cell_number))) + 
       geom_density(alpha = 0.5) +
       geom_vline(xintercept = cut_off_unmapped *100, colour="grey", linetype = "longdash") +
       labs(x = "Unmapped reads / Total reads per sample (%)", title = "Cutoff based on the percentage unmapped reads")

```

###ERCC Percentage  

```{r}
## calculate ercc reads percentage
summary_per_sample_reads_qc$ercc_percentage <- apply(reads_rm[grep("ERCC", rownames(reads_rm)), ],2,sum)/apply(summary_per_sample_reads_qc[,5:7],1,sum) 

## cut off 
cut_off_ercc <- quantile(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0,"ercc_percentage"], 0.05)

cut_off_ercc
```
This is looking at the percent of reads that map to the ERCC spike ins. We are looking at the lower 5% because higher than that assumes too much of the sample was composed of ERCC mapping reads rather than sample reads.  
```{r}
summary_per_sample_reads_qc$cut_off_ercc <- summary_per_sample_reads_qc$ercc_percentage < cut_off_ercc

## numbers of cells 
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "ercc_percentage"] >= cut_off_ercc)
```

```{r}
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "ercc_percentage"] < cut_off_ercc)
```


```{r}
## density plots
plot_ercc <- ggplot(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0 |
                                           summary_per_sample_reads_qc$cell_number == 1 , ],
       aes(x = ercc_percentage *100, fill = as.factor(cell_number))) + 
       geom_density(alpha = 0.5) +
       geom_vline(xintercept = cut_off_ercc *100, colour="grey", linetype = "longdash") +
       labs(x = "ERCC reads / Total mapped reads per sample", title = "Cutoff based on the percentage of ERCC reads")

```


```{r}
## endogenous genes
reads_rm_gene <- reads_rm[grep("ENSG", rownames(reads_rm)), ]

## number of genes detected 
summary_per_sample_reads_qc$gene_number <- colSums(reads_rm_gene >= 1)

## cut off 
cut_off_genes <- quantile(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0,"gene_number"], 0.95)

cut_off_genes
```

```{r}
summary_per_sample_reads_qc$cut_off_genes <- summary_per_sample_reads_qc$gene_number > cut_off_genes

## numbers of cells 
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "gene_number"] > cut_off_genes)
```

```{r}
sum(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 1, "gene_number"] <= cut_off_genes)
```

```{r}
## density plots
plot_gene <- ggplot(summary_per_sample_reads_qc[summary_per_sample_reads_qc$cell_number == 0 |
                                           summary_per_sample_reads_qc$cell_number == 1 , ],
       aes(x = gene_number, fill = as.factor(cell_number))) + 
       geom_density(alpha = 0.5) +
       geom_vline(xintercept = cut_off_genes, colour="grey", linetype = "longdash") +
       labs(x = "Gene numbers per sample", title = "Cutoff based on the number of detected genes")
```

```{r}
plot_grid(plot_reads + theme(legend.position=c(.7,.7)),
          plot_unmapped + theme(legend.position = "none"),
          plot_ercc + theme(legend.position = "none"), 
          plot_gene + theme(legend.position = "none"),
          labels = LETTERS[3:6])
```

**We should look at the numbers that fail in each of these tests. If they are similar we should see if the same cells make up that count in each of the tests. We would expect this if each of these are good tests for cell quality**  

###Total molecule counts  

```{r}
## calculate total gene molecule counts
summary_per_sample_reads_qc$total_gene_molecule <- colSums(molecules_rm[grep("ENSG", rownames(molecules_rm)),])

## look for outiers
ggplot(summary_per_sample_reads_qc, aes(x = concentration, y = total_gene_molecule / 10^3,
  color = as.factor(cell_number))) +
  geom_text(aes(label = cell_number)) +
  labs(x = "Concentration", y = "Gene molecules (thousands)") +
  scale_color_brewer(palette = "Dark2") +
  theme(legend.position = "none")
```

